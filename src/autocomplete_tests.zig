//! This is all machinary to unit test interactive shell auto completion.
//! Currently we only do bash.

//run: zig build -freference-trace test
// run: zig test %

const std = @import("std");
const util = @import("util.zig");
const autocomplete = @import("autocomplete.zig");

const FIFO_PIPE_NAME = "fifo_autocomplete_tests";

/// For quick debugging
fn bash(allocator: std.mem.Allocator, cmd: []const u8) std.ChildProcess.ExecError!std.ChildProcess.ExecResult {
    var argv = [_][]const u8{ "bash", "-c", cmd };
    return std.ChildProcess.exec(.{ .argv = &argv, .allocator = allocator });
}
const Shared = struct {
    // @TODO: We might be able to calculate this size from the test cases
    buffer: [10240]u8,
    bytes_read: usize,
};

// []struct {
//   the comp_line ('\t' representing when someone presses tab),
//   expected output as generated by our code,
// }
const AUTO_COMPLETE_TEST_CASES = blk: {
    const comp_lines: []const []const u8 = &[_][]const u8{
        "penzai a b c \t",
        "penzai a b\t",
    };

    const pree = "|";
    const post = "| ";

    //var b: []struct{ []const u8, []const u8 } = undefined;
    var ret: [comp_lines.len]struct { []const u8, []const u8 } = undefined;
    inline for (0.., comp_lines) |i, comp_line| {
        // @TODO: find out why this is 9 and not 64
        const info = autocomplete.construct_completion(comp_line, "9");
        const l = l: {
            var iter_state = autocomplete.CompLineIter{ .comp_line = info.comp_str };
            const iter = iter_state.iterator_interface();
            var count: u16 = 0;
            var joined_len: u16 = 0;
            while (iter.next()) |x| {
                count += 1;
                joined_len += pree.len + x.len + post.len;
            }
            break :l .{ .count = count, .joined_len = joined_len };
        };
        const joined_args = a: {
            var args: [l.joined_len]u8 = undefined;
            var iter_state = autocomplete.CompLineIter{ .comp_line = info.comp_str };
            const iter = iter_state.iterator_interface();
            var cursor: i16 = 0;
            while (iter.next()) |x| {
                @memcpy(args[cursor..][0..pree.len], pree);
                @memcpy(args[cursor + pree.len ..][0..x.len], x);
                @memcpy(args[cursor + pree.len + x.len ..][0..post.len], post);
                cursor += pree.len + x.len + post.len;
            }
            break :a args;
        };

        var buf: [info.count()]u8 = undefined;
        const result = info.printBuf(&buf) catch unreachable;
        std.debug.assert(buf.len == result.len);
        const cc = std.fmt.comptimePrint("COMP_CWORD:      |{d}|\n", .{l.count - 1});
        ret[i] = .{ comp_line, buf ++ cc ++ joined_args };
    }
    break :blk ret;
};

test "mock_bash_completions" {
    // @TODO: create the fifo pipe if it does not exit
    const allocator = std.heap.page_allocator;

    // cd to 'src' directory where the %[FIFO_PIPE_NAME] fifo pipe exists
    {
        var buffer: [std.fs.MAX_PATH_BYTES]u8 = undefined;
        const cwd_absolute = std.fs.cwd().realpath(".", &buffer) catch |err| std.debug.panic("Error: {?}\n Increase buffer size?", .{err});
        const basename = std.fs.path.basename(cwd_absolute);
        if (!std.mem.eql(u8, "src", basename)) {
            // You are probably running `zig build test` for this branch
            std.process.changeCurDir("src") catch |err| std.debug.panic("Could not cd to 'src': {?}", .{err});
            //std.debug.print("{s}", .{(try bash(allocator, "pwd")).stdout});
        }

        _ = std.fs.cwd().statFile(FIFO_PIPE_NAME) catch  {
            std.debug.panic("FIFO pipe 'src/" ++ FIFO_PIPE_NAME ++ "' does not exist", .{});
        };
    }


    var data: Shared = undefined;

    // Clear any messages from previous runs or manual testing.
    // We must spawn another thread because, when passing messages through FIFO
    // pipes both the read (off-loaded to the thread) and the write (`bash()`)
    // will block.
    {
        const handle = try std.Thread.spawn(.{}, struct {
            fn f(d: *Shared) !void {
                const fifo_pipe = try std.fs.cwd().openFile(FIFO_PIPE_NAME, .{ .mode = std.fs.File.OpenMode.read_only });
                defer fifo_pipe.close();

                // Not assuming buffer is big enough since there could be
                // abitrary input leftover
                var buf_reader = std.io.bufferedReader(fifo_pipe.reader());
                var in_stream = buf_reader.reader();
                while (try in_stream.readUntilDelimiterOrEof(&d.buffer, '\n')) |_| {}
            }
        }.f, .{&data});
        _ = try bash(allocator, "echo send output so that thread does not block >" ++ FIFO_PIPE_NAME);
        handle.join();
    }

    inline for (AUTO_COMPLETE_TEST_CASES) |tc| {
        data.bytes_read = 0;

        std.debug.print("Autocomplete test: |{s}|\n", .{tc[0]});
        const handle = try std.Thread.spawn(.{}, struct {
            fn f(d: *Shared) !void {
                const fifo_pipe = try std.fs.cwd().openFile(FIFO_PIPE_NAME, .{ .mode = std.fs.File.OpenMode.read_only });
                defer fifo_pipe.close();
                d.bytes_read = try fifo_pipe.reader().readAll(&d.buffer);
            }
        }.f, .{&data});
        pipe_to_interactive_bash(allocator, tc[0]) catch unreachable;
        handle.join();

        try std.testing.expectEqualStrings(data.buffer[0..data.bytes_read], tc[1]);
    }
}

// Wrapping child process execution and parsing bash output to unit test autocompletion
// This is somewhat hacky and not that robust
fn pipe_to_interactive_bash(allocator: std.mem.Allocator, comptime input: []const u8) !void {
    var process = std.ChildProcess.init(&.{ "bash", "--norc", "-i" }, allocator);
    process.stdin_behavior = .Pipe;
    process.stdout_behavior = .Pipe;
    process.stderr_behavior = .Pipe;

    // Cleanup STDERR so we see it better
    var env = std.process.EnvMap.init(allocator);
    try env.put("PS1", "> "); // Silence the default prompt to clean STDERR output
    process.env_map = @constCast(&env);

    // Make sure there is only one write to test so that our write to the FIFO
    // pipe does not stall
    const setup =
        \\pwd
        \\f() {
        \\  {
        \\    printf %s\\n "COMP_KEY:        |${COMP_KEY}|"
        \\    printf %s\\n "COMP_LINE:       |${COMP_LINE}|"
        \\    printf %s\\n "COMP_POINT:      |${COMP_POINT}|"
        \\    printf %s\\n "COMP_TYPE:       |${COMP_TYPE}|"
        \\    printf %s\\n "COMP_WORDBREAKS: |${COMP_WORBREAKS}|"
        \\    printf %s\\n "COMP_CWORD:      |${COMP_CWORD}|"
        \\    for x in "${COMP_WORDS[@]}"; do
        \\      printf '%s ' "|${x}|"
        \\    done
        \\  } >
    ++ FIFO_PIPE_NAME ++ "\n" ++
        \\}
        \\complete -F 'f' 'penzai'
        \\
    ;
    //std.debug.print("|{s}|\n|{s}|\n", .{setup, setup2});
    try process.spawn(); // initialise the stdio pipes.
    try process.stdin.?.writeAll(setup);
    try process.stdin.?.writeAll(input);
    try process.stdin.?.writeAll("\x01#"); // 0x01 is ^A or start of line, 0x03 should be ^C, but it does not seem to work
    process.stdin.?.close();
    process.stdin = null; // Otherwise .wait() will try to close STDIN again

    //var stdout = std.ArrayList(u8).init(allocator);
    //defer stdout.deinit();
    //var stderr = std.ArrayList(u8).init(allocator);
    //defer stderr.deinit();
    //try process.collectOutput(&stdout, &stderr, std.math.maxInt(usize));

    const termination = try process.wait();
    std.debug.assert(termination == .Exited);

    //std.debug.print("out |{s}|\n", .{stdout.items});
    //std.debug.print("err |{s}|\n", .{stderr.items});
}
